---
title: "Multi-Host Scaling"
description: "How OmniDaemon scales horizontally across multiple servers"
---

# Multi-Host Deployment & Scaling

> **OmniDaemon is "Kubernetes for AI Agents" - A universal runtime that makes AI agents autonomous, observable, and scalable.**

## Scaling Agents with Event-Driven Architecture

**EDA is the backbone of the transition to agentic systems.**

Its ability to decouple workflows while enabling real-time communication ensures that agents can operate efficiently at scale. Platforms like Kafka exemplify the advantages of EDA in an agent-driven system:

- **Horizontal Scalability**: Distributed design supports the addition of new agents or consumers without bottlenecks, ensuring the system grows effortlessly.
- **Low Latency**: Real-time event processing enables agents to respond instantly to changes, ensuring fast and reliable workflows.
- **Loose Coupling**: By communicating through topics rather than direct dependencies, agents remain independent and scalable.
- **Event Persistence**: Durable message storage guarantees that no data is lost in transit, which is critical for high-reliability workflows.

---

## Multi-Host Deployment (Technical Truth)

> [!IMPORTANT]
> This is how OmniDaemon multi-host works. No exaggeration, no lies - verified against the code.

**The architecture:**

```
┌─────────────────────────────────────────────────────────────────┐
│                    MULTI-HOST DEPLOYMENT                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  HOST 1                           HOST 2                        │
│  ┌─────────────────────┐          ┌─────────────────────┐       │
│  │ OmniDaemon + SDK    │          │ OmniDaemon + SDK    │       │
│  │                     │          │                     │       │
│  │ • AutoGen Agent     │          │ • LangGraph Agent   │       │
│  │ • CrewAI Agent      │          │ • Google ADK Agent  │       │
│  │ • Custom Agent      │          │ • AutoGen Agent     │       │
│  └──────────┬──────────┘          └──────────┬──────────┘       │
│             │                                │                  │
│             └────────────┬───────────────────┘                  │
│                          ▼                                      │
│               ┌─────────────────────┐                           │
│               │  SAME REDIS URL     │                           │
│               │  redis://prod:6379  │                           │
│               └─────────────────────┘                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**How consumer groups work:**

```python
# Unchanged behavior from redis_stream_bus.py:
group = group_name or (f"group:{topic}:{agent_name}")
```

**Message routing behavior:**

| Agents | Groups | Behavior |
|--------|--------|----------|
| Different `agent_name`, same topic | Different groups | **Broadcast** - ALL receive message |
| Same `agent_name`, same topic | Same group | **Load balance** - ONE receives message |

### Example Scenario

**Broadcast (Different Agents):**

```
Publisher sends event to topic: "file_tasks"
                     │
    ┌────────────────┼────────────────┐
    ▼                ▼                ▼
 autogen_agent   crewai_agent   langgraph_agent
 (Host 1)        (Host 1)       (Host 2)
 Group: A        Group: B       Group: C
    │                │               │
    ▼                ▼               ▼
 RECEIVES ✅      RECEIVES ✅     RECEIVES ✅
 (all 3 get the same message - different groups)
```

**Load Balancing (Scaling Same Agent):**

```
Publisher sends event to topic: "file_tasks"
                     │
    ┌────────────────┼────────────────┐
    ▼                ▼                ▼
 autogen_agent   autogen_agent   autogen_agent
 (Host 1)        (Host 2)        (Host 3)
 Group: A        Group: A        Group: A
    │                │               │
    ▼                ▼               ▼
 RECEIVES ✅      idle            idle
 (only 1 gets message - same group = load balanced)
```

### Why this works with ANY event bus

| Event Bus | Same Behavior |
|-----------|--------------|
| **Redis Streams** | Consumer groups: same group = competing, different = broadcast |
| **Kafka** | Consumer groups: same `group.id` = partition load balance, different = broadcast |
| **RabbitMQ** | Queues: same queue = round-robin, fanout exchange = broadcast per queue |

> [!NOTE]
> This is an **industry-standard pattern**. OmniDaemon uses it correctly.
> When Kafka/RabbitMQ backends are added, the SAME behavior is guaranteed.

**Requirements:**
1. OmniDaemon SDK on each host
2. Same Redis URL (or Kafka/RabbitMQ URL when supported)
3. That's it.
